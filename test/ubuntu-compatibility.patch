#!/usr/bin/env bash

# Ubuntu compatibility fixes for test-additional.sh

# This patch addresses the following Ubuntu-specific issues:
# 1. sed -i syntax differences between macOS and Linux
# 2. grep counting issues with ticket_name output
# 3. git branch parsing differences
# 4. temporary file handling

# Function to detect OS and use appropriate sed syntax
portable_sed_inplace() {
    local file="$1"
    shift
    
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # Linux (GNU sed)
        sed -i "$@" "$file"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS (BSD sed)
        sed -i '' "$@" "$file"
    else
        # Try GNU sed first, fall back to BSD
        sed -i "$@" "$file" 2>/dev/null || sed -i '' "$@" "$file"
    fi
}

# Export for use in tests
export -f portable_sed_inplace

# Fix for grep counting - ensure consistent output format
ensure_grep_count() {
    # Force grep to use consistent line counting
    export GREP_OPTIONS=""
    export LC_ALL=C
}

# Fix for git branch detection
portable_git_branch_count() {
    # Use git for-each-ref for more reliable branch counting
    git for-each-ref --format='%(refname:short)' refs/heads/ | grep -c "$1"
}

# Debug function to help diagnose issues
debug_ticket_list_output() {
    local output="$1"
    echo "=== DEBUG: ticket.sh list output ===" >&2
    echo "$output" >&2
    echo "=== DEBUG: grep for ticket_name ===" >&2
    echo "$output" | grep "ticket_name:" >&2
    echo "=== DEBUG: count ===" >&2
    echo "$output" | grep -c "ticket_name:" >&2
    echo "=== END DEBUG ===" >&2
}

# Apply fixes to test-additional.sh
apply_test_fixes() {
    local test_file="test-additional.sh"
    
    # Create a fixed version of the test file
    cat > "test-additional-fixed.sh" << 'EOF'
#!/usr/bin/env bash

# Additional test cases for ticket.sh
# Tests edge cases and error conditions not covered by other tests

# Source helper functions
source "$(dirname "$0")/test-helpers.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Test directory
TEST_DIR="test-additional-$(date +%s)"

# Ensure consistent environment
export LC_ALL=C
export GREP_OPTIONS=""

echo -e "${YELLOW}=== Additional ticket.sh Tests ===${NC}"
echo

# Portable sed in-place editing
portable_sed_inplace() {
    local file="$1"
    shift
    
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        sed -i "$@" "$file"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "$@" "$file"
    else
        # Try both syntaxes
        sed -i "$@" "$file" 2>/dev/null || sed -i '' "$@" "$file"
    fi
}

# Setup
setup_test() {
    rm -rf "$TEST_DIR"
    mkdir "$TEST_DIR"
    cd "$TEST_DIR"
    cp ../../ticket.sh .
    git init -q
    git config user.name "Test"
    git config user.email "test@test.com"
    echo "test" > README.md
    git add . && git commit -q -m "init"
    git checkout -q -b develop
    ./ticket.sh init >/dev/null
}

# Test result
test_result() {
    if [[ $1 -eq 0 ]]; then
        echo -e "  ${GREEN}✓${NC} $2"
    else
        echo -e "  ${RED}✗${NC} $2"
        [[ -n "${3:-}" ]] && echo "    Details: $3"
    fi
}

# Test 1: Duplicate ticket prevention
echo "1. Testing duplicate ticket prevention..."
setup_test
./ticket.sh new test-duplicate >/dev/null 2>&1

# Check if tickets directory exists
if [[ ! -d tickets ]]; then
    test_result 1 "Tickets directory not created"
else
    # Find first ticket file
    FIRST_TICKET=$(safe_get_first_file "*test-duplicate.md" "tickets")
    
    if [[ -z "$FIRST_TICKET" ]]; then
        test_result 1 "First ticket not created"
    else
        sleep 1  # Ensure different timestamp
        if ./ticket.sh new test-duplicate >/dev/null 2>&1; then
            # Find all matching files
            TICKET_COUNT=0
            for f in tickets/*test-duplicate.md; do
                if [[ -f "$f" ]]; then
                    ((TICKET_COUNT++))
                fi
            done
            
            if [[ $TICKET_COUNT -gt 1 ]]; then
                test_result 0 "Allows same slug with different timestamp"
            else
                test_result 1 "Should create different files for same slug"
            fi
        else
            test_result 1 "Should allow duplicate slug with different timestamp"
        fi
    fi
fi

# Test 2: Start already started ticket
echo -e "\n2. Testing start on already started ticket..."
git add . && git commit -q -m "add tickets"
TICKET_NAME=$(basename "$FIRST_TICKET" .md)
./ticket.sh start "$TICKET_NAME" --no-push >/dev/null 2>&1
git add . && git commit -q -m "update"
git checkout -q develop
if ./ticket.sh start "$TICKET_NAME" --no-push >/dev/null 2>&1; then
    test_result 1 "Should not allow starting already started ticket"
else
    test_result 0 "Correctly prevents starting already started ticket"
fi

# Test 3: Close from wrong branch
echo -e "\n3. Testing close from wrong branch..."
git checkout -q main 2>/dev/null || git checkout -q -b main
if ./ticket.sh close --no-push >/dev/null 2>&1; then
    test_result 1 "Should not allow close from non-feature branch"
else
    test_result 0 "Correctly prevents close from wrong branch"
fi

# Test 4: Restore with broken symlink
echo -e "\n4. Testing restore with broken symlink..."
git checkout -q "feature/$TICKET_NAME"
rm -f tickets/*.md  # Remove ticket file but keep symlink
if ./ticket.sh restore >/dev/null 2>&1; then
    test_result 1 "Should fail when ticket file is missing"
else
    test_result 0 "Correctly detects missing ticket file"
fi

# Test 5: List with various counts
echo -e "\n5. Testing list count parameter..."
cd .. && setup_test
# Create multiple tickets
for i in {1..5}; do
    ./ticket.sh new "test-$i" >/dev/null 2>&1
    sleep 0.1  # Small delay to ensure different timestamps
done

# Debug output
echo "Debug: Listing all tickets..." >&2
./ticket.sh list >&2

# Count tickets with explicit grep pattern
COUNT_1=$(./ticket.sh list --count 1 2>&1 | grep -E "^[[:space:]]*ticket_name:" | wc -l | tr -d ' ')
COUNT_3=$(./ticket.sh list --count 3 2>&1 | grep -E "^[[:space:]]*ticket_name:" | wc -l | tr -d ' ')
COUNT_10=$(./ticket.sh list --count 10 2>&1 | grep -E "^[[:space:]]*ticket_name:" | wc -l | tr -d ' ')

echo "Debug: Counts are 1=$COUNT_1, 3=$COUNT_3, 10=$COUNT_10" >&2

if [[ $COUNT_1 -eq 1 ]] && [[ $COUNT_3 -eq 3 ]] && [[ $COUNT_10 -eq 5 ]]; then
    test_result 0 "Count parameter works correctly"
else
    test_result 1 "Count parameter not working" "Got: 1=$COUNT_1, 3=$COUNT_3, 10=$COUNT_10"
fi

# Test 6: Invalid count values
echo -e "\n6. Testing invalid count values..."
if ./ticket.sh list --count 0 >/dev/null 2>&1; then
    test_result 1 "Should reject count 0"
else
    test_result 0 "Correctly rejects count 0"
fi

if ./ticket.sh list --count abc >/dev/null 2>&1; then
    test_result 1 "Should reject non-numeric count"
else
    test_result 0 "Correctly rejects non-numeric count"
fi

# Test 7: Custom branch prefix
echo -e "\n7. Testing custom branch prefix..."
cd .. && setup_test
# Modify config with portable sed
portable_sed_inplace .ticket-config.yml 's/branch_prefix: "feature\/"/branch_prefix: "ticket\/"/'

./ticket.sh new custom-branch >/dev/null 2>&1
git add . && git commit -q -m "add"
TICKET=$(safe_get_ticket_name "*custom-branch.md")
./ticket.sh start "$TICKET" --no-push >/dev/null 2>&1

BRANCH=$(git branch --show-current)
if [[ "$BRANCH" == "ticket/$TICKET" ]]; then
    test_result 0 "Custom branch prefix works"
else
    test_result 1 "Custom branch prefix not applied" "Got: $BRANCH"
fi

# Test 8: Dirty working directory
echo -e "\n8. Testing operations with dirty working directory..."
git checkout -q develop
echo "dirty" > dirty.txt
if ./ticket.sh start some-ticket --no-push >/dev/null 2>&1; then
    test_result 1 "Should prevent start with uncommitted changes"
else
    test_result 0 "Correctly prevents start with dirty directory"
fi

# Test 9: Multiple tickets workflow
echo -e "\n9. Testing multiple tickets workflow..."
cd .. && setup_test

# Create and start first ticket
./ticket.sh new "feature-a" >/dev/null 2>&1
git add . && git commit -q -m "add a"
TICKET_A=$(safe_get_ticket_name "*feature-a.md")
./ticket.sh start "$TICKET_A" --no-push >/dev/null 2>&1
git add . && git commit -q -m "start a"
echo "work a" > work-a.txt
git add . && git commit -q -m "work a"

# Go back and start second ticket
git checkout -q develop
./ticket.sh new "feature-b" >/dev/null 2>&1
git add . && git commit -q -m "add b"
TICKET_B=$(safe_get_ticket_name "*feature-b.md")
./ticket.sh start "$TICKET_B" --no-push >/dev/null 2>&1
git add . && git commit -q -m "start b"

# Check both branches exist using portable method
BRANCHES=$(git for-each-ref --format='%(refname:short)' refs/heads/ | grep -c "^feature/")
if [[ $BRANCHES -eq 2 ]]; then
    test_result 0 "Multiple feature branches can coexist"
else
    test_result 1 "Problem with multiple branches" "Found $BRANCHES branches"
fi

# Test 10: YAML frontmatter edge cases
echo -e "\n10. Testing YAML frontmatter handling..."
cd .. && setup_test

# Create ticket with special characters in description
cat > tickets/test-yaml.md << 'YAML_EOF'
---
priority: 1
tags: []
description: "Test with: colons and \"quotes\""
created_at: "2025-01-01T00:00:00Z"
started_at: null  # Do not modify manually
closed_at: null   # Do not modify manually
---

# Test Ticket
YAML_EOF

OUTPUT=$(./ticket.sh list 2>&1)
if echo "$OUTPUT" | grep -q "Test with: colons"; then
    test_result 0 "Handles special characters in YAML"
else
    test_result 1 "Problem with special characters in YAML"
fi

# Test 11: Priority sorting
echo -e "\n11. Testing priority sorting in list..."
cd .. && setup_test

# Create tickets with different priorities
for i in 3 1 2; do
    ./ticket.sh new "priority-$i" >/dev/null 2>&1
    TICKET=$(safe_get_first_file "*priority-$i.md" "tickets")
    if [[ -n "$TICKET" ]]; then
        portable_sed_inplace "$TICKET" "s/priority: 2/priority: $i/"
    fi
done

# Start one to test status+priority sorting
git add . && git commit -q -m "add all"
TICKET_2=$(safe_get_ticket_name "*priority-2.md")
./ticket.sh start "$TICKET_2" --no-push >/dev/null 2>&1

# Stay on feature branch to commit the started_at change
git add . && git commit -q -m "start ticket"

# Merge the change back to develop so started_at is visible
git checkout -q develop
git merge --no-ff -q "feature/$TICKET_2" -m "Merge feature branch" >/dev/null 2>&1

# Now check order in list from develop branch
LIST_OUTPUT=$(./ticket.sh list 2>&1)
# Get the first ticket name (should be priority-2 with doing status)
FIRST_TICKET=$(echo "$LIST_OUTPUT" | grep "ticket_name:" | head -1 | awk '{print $2}')
if [[ "$FIRST_TICKET" == *"priority-2"* ]]; then
    test_result 0 "Doing status shown first (status > priority)"
else
    test_result 1 "Priority sorting may be incorrect" "First ticket was: $FIRST_TICKET"
fi

# Test 12: Auto-push configuration
echo -e "\n12. Testing auto_push configuration..."
cd .. && setup_test

# Test with auto_push: true (default)
./ticket.sh new "push-test" >/dev/null 2>&1
git add . && git commit -q -m "add"
TICKET=$(safe_get_ticket_name "*push-test.md")

# Should show push command in output when auto_push is true
OUTPUT=$(./ticket.sh start "$TICKET" 2>&1)
if echo "$OUTPUT" | grep -q "git push"; then
    test_result 0 "Shows push command with auto_push: true"
else
    test_result 1 "Should show push attempt with auto_push: true"
fi

# Cleanup
cd ..
rm -rf "$TEST_DIR"

echo -e "\n${YELLOW}=== Additional tests completed ===${NC}"
EOF

    chmod +x test-additional-fixed.sh
    echo "Created fixed test file: test-additional-fixed.sh"
}

# Summary of fixes needed:
cat << 'SUMMARY'
Ubuntu Compatibility Issues Found:
1. sed -i syntax: Linux uses 'sed -i' while macOS uses 'sed -i ""'
2. grep counting: May need explicit pattern matching with spaces
3. git branch counting: Use git for-each-ref for reliability
4. Environment variables: Set LC_ALL=C and clear GREP_OPTIONS

Recommended fixes:
1. Use the portable_sed_inplace function for all sed operations
2. Use explicit grep patterns with proper escaping
3. Use wc -l | tr -d ' ' for consistent counting
4. Set environment variables at test start
SUMMARY